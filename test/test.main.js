// Generated by CoffeeScript 1.6.1

(function(global){
if( typeof(settee) == 'undefined' && typeof(expect) == 'undefined' && typeof(require) != 'undefined'){
  settee= require('../settee.js').settee;
  expect= require('chai').expect;
}
})(this);
var expected_output, global, source_indented, source_inline, _set;

global = this;

_set = null;

source_indented = '(html\n  (head\n    (title "Test"))\n  (body\n    (p "...")))';

source_inline = '(html (head (title "Test")) (body (p "...")))';

expected_output = '<html><head><title>Test</title></head><body><p>...</p></body></html>';

describe("settee() v" + settee.version, function() {
  it('should exist', function() {
    expect(settee).to.not.be.undefined;
    return expect(settee).to.be.a('function');
  });
  it("should generate <html> for (html)", function() {
    var result, tmpl;
    tmpl = settee('(html)');
    result = tmpl();
    expect(result).to.be.an('string');
    return expect(result).to.equal("<html></html>");
  });
  it('should generate <html lang="en"> for (html lang="en")', function() {
    var result, tmpl;
    tmpl = settee('(html  lang="en")');
    result = tmpl();
    expect(result).to.be.an('string');
    return expect(result).to.equal('<html lang="en"></html>');
  });
  it('should generate <html lang="en"> for (html lang=en)', function() {
    var result, tmpl;
    tmpl = settee('(html  lang=en)');
    result = tmpl();
    expect(result).to.be.an('string');
    return expect(result).to.equal('<html lang="en"></html>');
  });
  it('should generate properly nested html', function() {
    var result, tmpl;
    tmpl = settee(source_inline);
    result = tmpl();
    expect(result).to.be.an('string');
    return expect(result).to.equal(expected_output);
  });
  it('should not generate a tag for .', function() {
    return expect(settee('(. "Hello")')()).to.equal('Hello');
  });
  it('should reference data from context as :varname', function() {
    var ctx;
    ctx = {
      name: 'Matt',
      city: 'Dallas'
    };
    expect(settee('(. :name)')(ctx)).to.equal(ctx.name);
    expect(settee('(p "My name is " :name)')(ctx)).to.equal("<p>My name is Matt</p>");
    return expect(settee('(p @name)')(ctx)).to.equal('<p>Matt</p>');
  });
  it('should reference env variable by @symbol too', function() {
    expect(settee("(. @name)")({
      name: "Matt"
    })).to.equal('Matt');
    return expect(settee("(. @city)")({
      city: "Dallas"
    })).to.equal('Dallas');
  });
  it('should support (if expr, truelist)', function() {
    var src;
    src = '(if (eq :name "Matt")(div "Hello!"))';
    expect(settee.render(src)).to.equal("");
    return expect(settee.render(src, {
      name: 'Matt'
    })).to.equal("<div>Hello!</div>");
  });
  it('should support (ifelse expr, truelist, falselist)', function() {
    var src;
    src = '(ifelse (eq :name "Matt")\n  (div "Hello!")\n  (div "Who?"))';
    expect(settee.render(src)).to.equal("<div>Who?</div>");
    return expect(settee.render(src, {
      name: 'Matt'
    })).to.equal("<div>Hello!</div>");
  });
  it('should support (unless expr, iffails...)', function() {
    var src;
    src = '(unless (is :name "Matt")\n  (div "Hello!"))';
    expect(settee.render(src)).to.equal("<div>Hello!</div>");
    return expect(settee.render(src, {
      name: 'Matt'
    })).to.equal("");
  });
  it('should support simple looping over an Array', function() {
    var data, src;
    src = '(ul.list\n  (loop :list\n    (li.item :item)\n  )\n)';
    data = {
      list: ["Matt", "Dan", "Sam"]
    };
    return expect(settee.render(src, data)).to.equal('<ul class="list"><li class="item">Matt</li><li class="item">Dan</li><li class="item">Sam</li></ul>');
  });
  it('should support simple looping over an Array of Objects', function() {
    var data, src;
    src = '(ul.list\n  (loop :list\n    (li.item :item.name)\n  )\n)';
    data = {
      list: [
        {
          name: "Matt"
        }, {
          name: "Dan"
        }, {
          name: "Sam"
        }
      ]
    };
    return expect(settee.render(src, data)).to.equal('<ul class="list"><li class="item">Matt</li><li class="item">Dan</li><li class="item">Sam</li></ul>');
  });
  describe("generated output", function() {
    var _this = this;
    it("should return an html string", function() {
      var html, t;
      t = settee(source_inline);
      html = t();
      return expect(html).to.equal(expected_output);
    });
    it("should not care about source whitespace (indention)", function() {
      var t;
      t = settee(source_indented);
      return expect(t()).to.equal(expected_output);
    });
    it("should support quoted or unquoted attributes", function() {
      expect(settee('(div id="main")')()).to.equal('<div id="main"></div>');
      return expect(settee('(div id=main)')()).to.equal('<div id="main"></div>');
    });
    it("should add class shortcuts (div.list.active)", function() {
      expect(settee('(div.list)')()).to.equal('<div class="list"></div>');
      return expect(settee.render('(div.list.active)')).to.equal('<div class="list active"></div>');
    });
    it("should default to div for (.list.active)", function() {
      expect(settee.render('(.list)')).to.equal('<div class="list"></div>');
      expect(settee.render('(.list.active)')).to.equal('<div class="list active"></div>');
      return expect(settee.render('(.list#main)')).to.equal('<div id="main" class="list"></div>');
    });
    it("should add id shortcut (div#main)", function() {
      expect(settee('(div#main)')()).to.equal('<div id="main"></div>');
      return expect(settee.render('(div#main.list.active)')).to.equal('<div id="main" class="list active"></div>');
    });
    it("should default to div for (#main)", function() {
      expect(settee.render('(#main)')).to.equal('<div id="main"></div>');
      expect(settee.render('(#main.test)')).to.equal('<div id="main" class="test"></div>');
      return expect(settee.render('(.test#main)')).to.equal('<div id="main" class="test"></div>');
    });
    it("should allow mixing shortcut types (div#main.container)", function() {
      expect(settee.render('(div#main.list)')).to.equal('<div id="main" class="list"></div>');
      expect(settee.render('(div#main.list.active)')).to.equal('<div id="main" class="list active"></div>');
      expect(settee.render('(div.list#main.active)')).to.equal('<div id="main" class="list active"></div>');
      return expect(settee.render('(div.list.active#main)')).to.equal('<div id="main" class="list active"></div>');
    });
    it('should support auto_tag generation: <crap></crap> for (crap)', function() {
      var res;
      res = settee.render('(crap)');
      expect(res).to.equal('<crap></crap>');
      res = settee('(crap.active)');
      return expect(res()).to.equal('<crap class="active"></crap>');
    });
    it('should swallow null/undefined when using (. :varname)', function() {
      var res, src;
      src = '(div "Hello" (. :name))';
      res = settee.render(src, {
        name: null
      });
      expect(res).to.equal("<div>Hello</div>");
      src = '(div "Hello " (. :name :city))';
      res = settee.render(src, {
        city: "Dallas"
      });
      return expect(res).to.equal("<div>Hello Dallas</div>");
    });
    it('should render precompiled templates', function() {
      var res, tmp;
      tmp = settee.precompile('(html (body :city');
      res = settee.render(tmp, {
        city: "Dallas"
      });
      expect(res).to.equal("<html><body>Dallas</body></html>");
      res = settee(tmp);
      return expect(res({
        city: "Dallas"
      })).to.equal("<html><body>Dallas</body></html>");
    });
    it('should allow creating custom tags / helpers', function() {
      var expected, output, src;
      settee.define('widget', '(div.widget (div.body :block1');
      src = '(widget\n  (div "Hello!"))';
      output = settee.render(src);
      expected = '<div class="widget"><div class="body"><div>Hello!</div></div></div>';
      expect(output).to.equal(expected);
      settee.undefine('widget');
      return expect(settee('(widget)')()).to.equal("<widget></widget>");
    });
    it('should allow creating custom tags / helpers from precompiled templates', function() {
      var expected, output, src;
      settee.define('widget', '(div.widget (div.body :block1');
      src = '(widget\n  (div "Hello!"))';
      output = settee.render(src);
      expected = '<div class="widget"><div class="body"><div>Hello!</div></div></div>';
      expect(output).to.equal(expected);
      settee.undefine('widget');
      return expect(settee('(widget)')()).to.equal("<widget></widget>");
    });
    return it('should allow adding attrs to custom tags', function() {
      var expected, output, src;
      settee.define('widget', function(tag, attrs, elements) {
        attrs["class"] = 'widget';
        return settee.tag_builder('div', attrs, [
          settee.tag_builder('div', {
            "class": 'body'
          }, elements)
        ]);
      });
      src = '(.\n(widget id=mine\n  (div "Hello!"))\n(widget id=yours \n  (div "Hello!")\n  (div "GOODBYE!"))';
      output = settee.render(src);
      expected = '<div id="mine" class="widget"><div class="body"><div>Hello!</div></div></div><div id="yours" class="widget"><div class="body"><div>Hello!</div><div>GOODBYE!</div></div></div>';
      return expect(output).to.equal(expected);
    });
  });
  return describe('noConflict()', function() {
    beforeEach(function() {
      return _set = settee.noConflict();
    });
    afterEach(function() {
      return global.settee = _set;
    });
    it('should remove settee from the global scope', function() {
      return expect(global.settee).to.be.undefined;
    });
    it('should return the settee function', function() {
      expect(_set).to.be.a["function"];
      return expect(_set.render).to.be.a["function"];
    });
    return describe('disconnected settee function', function() {
      return it('should still be usable', function() {
        return expect(_set.render("(div (span 'hello'")).to.equal('<div><span>hello</span></div>');
      });
    });
  });
});
