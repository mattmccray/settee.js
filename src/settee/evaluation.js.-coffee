###

OPERATIONS:
  Arguments are the evaluated list atoms

FUNCTIONS:
  Arguments are unevaluated list nodes

###

# For handling evaluated exprs
Settee.op=
  # lisp-y list-y stuff
  first: ->
    l= arguments[0]
    return null if !l or !l.length
    l[0]
  rest: ->
    l= arguments[0]
    return [] if !l or !l.length
    l.slice(1)
  cons: ->
    a= arguments[1]
    return [arguments[0]] unless a
    a.unshift arguments[0]
    a
  
  # Logical
  not: ->
    !arguments[0]
  and: ->
    for arg in arguments
      return false if !arg
    true
  or: ->
    for arg in arguments
      return true if arg
    false
  
  # Comparison
  "<=": (x,y)-> x <= y
  "<": (x,y)-> x < y
  ">=": (x,y)-> x >= y
  ">": (x,y)-> x > y
  "=": (x,y)-> x == y
  "eq": (x,y)-> x == y
  "neq": (x,y)-> x != y
  
  # Arithmetic
  "+": -> # supports numbers or strings (acts as concat)
    res= if isNaN(arguments[0]) then "" else 0
    _.each arguments, (x,i)-> res += x
    res
  "-": ->
    res= arguments[0] * 2
    _.each arguments, (x,i)-> res -= x
    res
  "*": ->
    res= 1
    _.each arguments, (x,i)-> res *= x
    res
  "/": ->
    res= arguments[0] * arguments[0]
    _.each arguments, (x,i)-> res /= x
    res
  ".": -> # concat that swallows nulls/undefined as ""
    res= ""
    _.each arguments, (x,i)-> 
      unless x is null or _.isUndefined(x)
        res += x
      else
        ""
    res

  # TODO: let?

# for LISP nerds
Settee.op.car=Settee.op.first
Settee.op.cdr=Settee.op.rest

# Truthy test same as 'and'
Settee.op["?"]=Settee.op.and
  

# For handling raw exprs
Settee.fn= 
  print_r: (expr, env, evaluate)->
    Settee._.log expr

  # Atom
  '"': (expr, env, _evaluate)->
    v= expr.slice(1) 
    #TODO: String interpolation.
    return v.replace(/[\\]"/g, '"')
  
  # Get's env variable, swallows null (and all falsy really)
  ':': (expr, env, _evaluate)->
    key= expr.slice(1)
    val=get_env(key,env)
    return val or ""

  # Conditionals
  "if": (expr, env, _evaluate)->
    return _evaluate expr[2], env if _evaluate expr[1], env
    return "" if expr.length <= 3  # DID RETURN NULL
    _.each(expr.slice(2, expr[expr.length - 2]), (x,i)->
      _evaluate x, env
    )
    return _evaluate expr[expr.length - 1], env

  "case": (expr, env, _evaluate)->
    # TODO: Should a (case) statement have an else clause?
    cases= expr.slice(1, expr.length)
    for rule in cases
      return _evaluate(rule[rule.length - 1], env) if _evaluate rule[0], env
    return null # since there's no cond match?

  # List
  "list": (expr, env, _evaluate)->
    return _.map(expr.slice(1), (x)->
      v= _evaluate x, env
      return Array v if _.isArray(v)
      v
    )

  # not sure if this is really right or not...
  'quote': (expr, env, _evaluate)->
    v=expr[1]
    # Just to pull out our string ident
    return v.slice(1).replace(/[\\]"/g, '"') if v[0] is '"' 
    return v

  # Variables
  "set": (expr, env, _evaluate)->
    variable= env[expr[1]]= _evaluate(expr[2], env)
    return variable

  'each': (expr, env, _evaluate)->
    # [target,keyword,source]=expr[1]
    source= expr[1][0]
    res=[]
    for data in _evaluate(source, env)
      newenv= data
      newenv['_parent']= env
      # newenv['_loop']= idx
      res.push _evaluate(expr[2], newenv)
      # delete newenv['_parent']
    return res.join('') #?

  'lambda': (expr, env, _evaluate)->
    return make_proc expr[1], expr.slice(2), env

  'def': (expr, env, _evaluate)->
    return env[expr[1]]= make_proc expr[2], expr.slice(3), env

  'js': (expr, env, _evaluate)->
    return eval(expr[1])


# More LISP nerdery
Settee.fn.cond= Settee
Settee.fn.setq= Settee.fn['set!']= Settee
Settee.fn.defun= Settee


# HTML Tags

Settee.tags= {}

Settee.tags[tagName]= _.tag_builder for tagName in "a abbr address area article aside audio b base bdi bdo blockquote body br button canvas caption cite code col colgroup command data datalist dd del details dfn div dl dt em embed eventsource fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link mark map menu meta meter nav noscript object ol optgroup option output p param pre progress q ruby rp rt s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(' ')

get_env= (expr,env)->
  return false if typeof(expr) isnt "string"
  return env[expr] if expr of env
  if (parts= expr.split('.')).length > 1
    if parts[0] of env
      obj=env
      for part in parts
        obj= obj[part] #if obj[part]
      return obj if obj != env
  return get_env(expr, env['_parent']) if '_parent' of env
  #false
  null

has_env= (expr,env)->
  return false if typeof(expr) isnt "string"
  return true if expr of env
  if (parts= expr.split('.')).length > 1
    if parts[0] of env
      obj=env
      for part in parts
        obj= obj[part] #if obj[part]
      return true if obj != env # ???
  return has_env(expr, env['_parent']) if '_parent' of env
  false

apply_to= (proc, args)->
  return proc.apply(@, args) if _.isFunction proc
  throw "Procedure #{proc} is not defined"

make_proc= (args, body, env)->
  (params...)->
    newenv= {}
    newenv['_parent']= env
    _.each args, (x,i)-> newenv[x]= params[i]
    _.each body.slice(0, body.length-1), (x,i)-> _evaluate(x, newenv)
    _evaluate body[body.length-1], newenv

_do_evaluate= (code, env={}, opts={})->
  env['@auto_tag']= if opts.auto_tag then yes else no
  _evaluate(code,env)

_evaluate= (expr, env)->
  ez= expr[0]

  # Atoms
  return null if expr is "nil" or expr is "null" or expr is null
  return Number expr if not isNaN expr

  # Variables
  return ge if (ge= get_env(expr,env))

  # Functions
  return Settee.fn[ez](expr, env, _evaluate) if ez of Settee.fn

  # Operators
  return Settee.op[expr] if expr of Settee.op

  # Tags
  if ez of Settee.tags
    return Settee.tags[ez](expr, env, _evaluate)
  else if typeof(ez) is 'string' and (parts= ez.split('.')).length > 1
    if parts[0] of Settee.tags
      return Settee.tags[parts[0]](expr, env, _evaluate)

  # Auto tag support
  if get_env('@auto_tag', env)
    ev= (src)-> _evaluate src, env
    return _.tag_builder(expr, ev)

  # Apply
  if _.isArray expr
    return apply_to(
      _evaluate(ez, env),
      _.map(expr.slice(1), (x,i)-> 
        v= _evaluate x, env
        if _.isArray(v) then Array v else v
      )
    )
  
  # TODO: look for a method_missing or missing or unknown handler in the list of ops/fns/env and call it?

  throw "#{expr} is not defined."
