
root= @

has_console= 
  try
    if console and console.log then yes else no
  catch ex
    no
can_apply_log= 
  try
    console.log.apply console, []
    yes
  catch ex
    no

breaker = {}

ArrayProto = Array::
StringProto = String::
slice            = ArrayProto.slice
nativeForEach      = ArrayProto.forEach
nativeMap          = ArrayProto.map
nativeIsArray      = Array.isArray
nativeTrim         = StringProto.trim

escapeRegExp= (str)->
  # From MooTools core 1.2.4
  str.replace /([-.*+?^${}()|[\]\/\\])/g, '\\$1'

quotedAttrRE= /([\w]*)="([\w ]*)"/
attrRE= /([\w]*)=([\w]*)/

Settee._= _=
  map: (obj, iterator, context)->
    results = []
    return results if obj is null
    return obj.map(iterator, context) if nativeMap and obj.map is nativeMap
    _.each obj, (value, index, list) ->
      results[results.length]= iterator.call(context, value, index, list)
    results.length = obj.length if obj.length is +obj.length
    results

  each: (obj, iterator, context)->
    return if obj is null
    if nativeForEach and obj.forEach is nativeForEach
      obj.forEach iterator, context

    else if obj.length is +obj.length
      for item,idx in obj
        return if idx of obj and iterator.call(context, item, idx, obj) is breaker

    else
      for own key,item of obj
        return if iterator.call(context, item, key, obj) is breaker

  breakLoop: -> throw breaker
  
  extend: (obj)->
    _.each slice.call(arguments, 1), (source)->
      for prop,value of source
        obj[prop]= value
    obj
  
  defaults: (obj)->
    _.each slice.call(arguments, 1), (source)->
      for prop,value of source
        obj[prop]= value unless obj[prop]
    obj

  # Find something better than RegExp?  
  trim: (str, char)->
    return "" if str is null
    return nativeTrim.call(str) if !char and nativeTrim
    char= if char
      escapeRegExp(char)
    else
      '\\s'
    str.replace new RegExp('\^[' + characters + ']+|[' + characters + ']+$', 'g'), ''
    str.replace /^[#{char}]+|[#{char}]+$/g, ''

  isString: (obj) -> 
    !!(obj is '' or (obj and obj.charCodeAt and obj.substr))

  isArray: nativeIsArray or (obj) ->
    !!(obj and obj.concat and obj.unshift and not obj.callee)

  isFunction: (obj) ->
    !!(obj and obj.constructor and obj.call and obj.apply)

  isUndefined: (obj) -> `obj === void 0`

  # Attribute stuff?
  parseAttrs: (val, as_string=yes)->
    if _.isString(val)
      if quotedAttrRE.test(val)
        # Ewok.log("matches", val.match(quotedAttrRE))
        [full,key,value]= val.match(quotedAttrRE)
        return "#{key}=\"#{value}\"" if as_string
        {key,value}
      else if attrRE.test(val)
        # Ewok.log("matches", val.match(attrRE))
        [full,key,value]= val.match(attrRE)
        return "#{key}=\"#{value}\"" if as_string
        {key,value}
      else
        false
    else
      false
  
  extractAttrs: (expr, parse=no, recurse=no)->
    atts= if parse then {} else []
    idx=[]
    for atom,i in expr
      if (att= _.parseAttrs(atom, !parse))
        if parse
          atts[att.key]= att.value
        else
          atts.push att
        idx.push i
    expr.splice i, 1 for i in idx.reverse()
    atts


  replaceArrayVal: (arr, key, value, all=no)->
    items= arr
    idx= []
    for item,i in arr
      if item is key
        idx.push i
        break unless all
      else if _.isArray item
        _.replaceArrayVal(item, key, value, all)
    arr.splice i, 1, value for i in idx  
    arr

  tag_builder: (expr, env, evaluate)->
    body= ""
    attrs= ""
    tag= expr[0]
    if (parts= tag.split('.')).length > 1
      tag= parts.shift() or "div"
      attrs += " class=\"#{parts.join(' ')}\""
    for exp in expr[1...]
      if attr= _.parseAttrs(exp)
        attrs += " "+ attr
      else
        if exp[0] is '@'
          key = if exp[1][0] is '"'
            evaluate(exp[1], env)
          else
            exp[1]
          attr= " #{key}=\"#{evaluate(exp[2], env)}\""
          attrs += attr
        else
          body += evaluate exp, env
    "<#{tag}#{attrs}>#{body}</#{tag}>"

  log: (->
    if has_console
      if can_apply_log
        (args...)->
          console.log.apply console, args
      else
        (args...)-> # Stupid IE
          for arg in args
            console.log arg
    else
      -> # NOOP
  )()

  # bench: (times=1000)->
  #   src= '''
  #         (html
  #           (head
  #             (title "Test Page")
  #           )
  #           (body
  #             (h1 "Test Page")
  #           )
  #         )
  #        '''
  #   start= (new Date).getTime()
  #   for item in [0...times]
  #     output= Settee.to_html(src)
  #   delta= (new Date).getTime() - start
  #   alert "#{times} operations took #{delta}ms."
  #   output
  # bench2: (times=1000)->
  #   src= '''
  #         (html
  #           (head
  #             (title "Test Page")
  #           )
  #           (body
  #             (h1 "Test Page")
  #             (p "hello " name)
  #           )
  #         )
  #        '''
  #   start= (new Date).getTime()
  #   for item in [0...times]
  #     output= Settee.to_html(src, { name:"Me" })
  #   delta= (new Date).getTime() - start
  #   alert "#{times} operations took #{delta}ms."
  #   output
  # bench2b: (times=1000)->
  #   src= '''
  #         (html
  #           (head
  #             (title "Test Page")
  #           )
  #           (body
  #             (h1 "Test Page")
  #             (p "hello " name)
  #           )
  #         )
  #        '''
  #   start= (new Date).getTime()
  #   tmpl= Settee(src)
  #   for item in [0...times]
  #     output= tmpl({ name:"Me" })
  #   delta= (new Date).getTime() - start
  #   alert "#{times} operations took #{delta}ms."
  #   output
  # bench2c: (times=1000)->
  #   src= '''
  #         (html
  #           (head
  #             (title "Test Page")
  #           )
  #           (body
  #             (h1 "Test Page")
  #             (p "hello " name)
  #           )
  #         )
  #        '''
  #   start= (new Date).getTime()
  #   tmpl= new Settee(src)
  #   for item in [0...times]
  #     output= tmpl.render({ name:"Me" })
  #   delta= (new Date).getTime() - start
  #   alert "#{times} operations took #{delta}ms."
  #   output
  # bench3: (times=1000)->
  #   src= '''
  #         (def widget (body)
  #           (div.widget
  #             (div.title "Title")
  #             (div body)))
  #         (html
  #           (head
  #             (title "Test Page")
  #           )
  #           (body
  #             (h1 "Test Page")
  #             (p "hello " name)
  #             (aside
  #               (widget 
  #                 (div.content "I'm the content!")))
  #           )
  #         )
  #        '''
  #   start= (new Date).getTime()
  #   tmpl= Settee(src)
  #   for item in [0...times]
  #     output= tmpl({ name:"Me" })
  #   delta= (new Date).getTime() - start
  #   alert "#{times} operations took #{delta}ms."
  #   output
  # bench4: (times=1000)->
  #   Settee.define('widget', '(div.widget (div.body :blocks')
  #   src= '''
  #         (html
  #           (head
  #             (title "Test Page")
  #           )
  #           (body
  #             (h1 "Test Page")
  #             (p "hello " name)
  #             (aside
  #               (widget 
  #                 (div.content "I'm the content!")))
  #           )
  #         )
  #        '''
  #   start= (new Date).getTime()
  #   tmpl= Settee(src)
  #   for item in [0...times]
  #     output= tmpl({ name:"Me" })
  #   delta= (new Date).getTime() - start
  #   alert "#{times} operations took #{delta}ms."
  #   output


